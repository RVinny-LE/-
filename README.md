ЗАДАНИЕ 2. Реализация пакета модулей для манипулирования плоскими фигурами.
Реализовать API, которое позволяет генерировать, преобразовывать и визуализировать последовательность плоских полигонов, представленных в виде картежа картежей (например: ((0,0), (0,1), (1,1), (1,0)) — представление для квадрата). Последовательности представлений полигонов представляют собой итераторы (далее: последовательности полигонов). Решать задачи с использованием функционального стиля программирования, в том числе активно использовать функции из модуля itertools и functools.

Суммарная сложность дополнительных заданий должна быть не менее 5.

Реализовать функцию визуализации последовательности полигонов, представленной в виде итератора (например, можно использовать визуализацию с помощью библиотеки matplotlib, см. пример: ссылка).
обязательная часть

Реализовать функции, генерирующие бесконечную последовательность непересекающихся полигонов с различающимися координатами (например, «ленту», см. рис. 2):
прямоугольников (gen_rectangle);

треугольников (gen_triangle);

правильных шестиугольников (gen_hexagon).

с помощью данных функций используя функции из модуля itertools сгенерировать семь фигур, включающих как прямоугольники, так и треугольники и шестиугольники, визуализировать результат.

обязательная часть

12.png

Рисунок 2 — Последовательности непересекающихся полигонов

Реализовать операции:
параллельный перенос (tr_translate);

поворот (tr_rotate);

симметрия (tr_symmetry);

гомотетия (tr_homothety);

которые можно применить к последовательности полигонов с помощью функции map.

обязательная часть

С помощью данных функций создать и визуализировать (рис. 3):
три параллельных «ленты» из последовательностей полигонов, расположенных под острым углом к оси абсцисс;

две пересекающихся «ленты» из последовательностей полигонов, пересекающихся не в начале координат;

две параллельных ленты треугольников, ориентированных симметрично друг к другу;

последовательность четырехугольников в разном масштабе, ограниченных двумя прямыми, пересекающимися в начале координат.

обязательная часть

333.png

Рисунок 3 — Реализация операции параллельного переноса (а), поворота (б), симметрии (в) и гомотетии (г)

Реализовать операции:
фильтрации фигур, являющихся выпуклыми многоугольниками (flt_convex_polygon);

фильтрации фигур, имеющих хотя бы один угол, совпадающий с заданной точкой (flt_angle_point);

фильтрации фигур, имеющих площадь меньше заданной (flt_square);

фильтрации фигур, имеющих кратчайшую сторону меньше заданного значения (flt_short_side);

фильтрации выпуклых многоугольников, включающих заданную точку (внутри многоугольника) (flt_point_inside);

фильтрации выпуклых многоугольников, включающих любой из углов заданного многоугольника (flt_polygon_angles_inside);

которые можно применить к последовательности полигонов с помощью функции filter.

обязательная часть: 2 пункта
4 пункта — сложность 1
6 пунктов — сложность 2

С помощью данных функций реализовать и визуализировать:
фильтрацию фигур, созданных в рамках пункта 4.4; подобрать параметры так, чтобы на выходе было получено шесть фигур;

используя функции генерации из п. 2 и операции из п. 3, создать не менее 15 фигур, которые имеют различный масштаб, и выбрать из них (подбором параметра фильтрации) не более четырех фигур, имеющих кратчайшую сторону меньше заданного значения;

используя функции генерации из п. 2 и операции из п. 3, создать не менее 15 фигур имеющих множество пересечений и обеспечить фильтрацию пересекающихся фигур.

обязательная часть: 1 пункт
3 пункта — сложность 1

Реализовать декораторы и продемонстрировать корректность их работы:
фильтрующие многоугольники в итераторах среди аргументов функции, работающие на основе функций из п. 5: @flt_convex_polygon, @flt_angle_point, @flt_square, @flt_short_side, @flt_point_inside, @flt_polygon_angles_inside;

преобразующие многоугольники в итераторах среди аргументов функции, работающие на основе функций из п. 3: @tr_translate, @tr_rotate, @tr_symmetry, @tr_homothety.

обязательная часть: 1 пункт
5 пунктов — сложность 1

Реализовать функции и продемонстрировать их корректность:
поиск угла, самого близкого к началу координат (agr_origin_nearest);

поиск самого длинной стороны многоугольника (agr_max_side);

поиск самой маленькой площади многоугольника (agr_min_area);

расчет суммарного периметра (agr_perimeter);

расчет суммарной площади (agr_area);

которые можно применить к последовательности полигонов с помощью функции functools.reduce.

3 пункта — сложность 1
5 пунктов — сложность 2

Реализовать функции и продемонстрировать пример их работы (если возможно, с визуализацией):
склейки полигонов в одну последовательность полигонов из нескольких последовательностей полигонов zip_polygons(iterator1, iterator2, [iterator3, ...]). Пример:

zip_polygons([((1, 1), (2, 2), (3, 1)), ((11, 11), (12, 12), (13, 11))], [((1, -1), (2, -2), (3, -1)), ((11, -11), (12, -12), (13, -11))]) →

[((1, 1), (2, 2), (3, 1), (1, -1), (2, -2), (3, -1)), ((11, 11), (12, 12), (13, 11), (11, -11), (12, -12), (13, -11))].

Альтернативный пример (визуализация) на рис. 4.

44.png

Рисунок 4 — Альтернативный пример склейки полигонов

генерации count_2D() параметры: (start1, start2), [(step1, step2)], результаты: (start1, start2), (start1+step1, start2+step2), (start1+2*step1, start2+2*step2);

склейки полигонов в одну последовательность полигонов из нескольких последовательностей zip_tuple(iterator1, iterator2). Пример:

zip_tuple([(1,1), (2,2), (3,3), (4,4)], [(2,2), (3,3), (4,4), (5,5)], [(3,3), (4,4), (5,5), (6,6)]) →

((1,1), (2,2), (3,3)), ((2,2), (3,3) (4,4)), ((3,3), (4,4), (5,5)), ((5,5), (6,6), (7,7)).

3 пункта — сложность 1

